package com.example.furniturecloudy.util

import android.util.Log
import com.example.furniturecloudy.data.Product
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.tasks.await
import kotlin.random.Random

/**
 * Manager Ä‘á»ƒ insert vÃ  delete fake data trÃªn Firebase
 *
 * ğŸ¯ CÃCH DÃ™NG:
 * 1. Gá»i insertFakeProducts() Ä‘á»ƒ insert 1000-5000 fake products
 * 2. Sau khi xong mÃ´n há»c, gá»i deleteAllFakeProducts() Ä‘á»ƒ xÃ³a sáº¡ch
 *
 * âš ï¸ CHÃš Ã:
 * - Fake products cÃ³ field `isFakeData = true` Ä‘á»ƒ phÃ¢n biá»‡t vá»›i real data
 * - KHÃ”NG XÃ“A products cÃ³ isFakeData = false (hoáº·c khÃ´ng cÃ³ field nÃ y)
 */
object FirebaseFakeDataManager {

    private const val TAG = "FakeDataManager"
    private const val COLLECTION_PRODUCTS = "Products"

    // Categories tháº­t tá»« app
    private val categories = listOf(
        "Chair",
        "Table",
        "Cupboard",
        "Accessory",
        "Furniture"
    )

    private val adjectives = listOf(
        "Modern",
        "Classic",
        "Vintage",
        "Luxury",
        "Minimalist",
        "Rustic",
        "Contemporary",
        "Traditional",
        "Industrial",
        "Scandinavian",
        "Elegant",
        "Stylish"
    )

    private val materials = listOf(
        "Wood",
        "Metal",
        "Glass",
        "Leather",
        "Fabric",
        "Plastic",
        "Bamboo",
        "Rattan"
    )

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // INSERT FAKE DATA
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

    /**
     * Insert fake products lÃªn Firebase
     *
     * @param count Sá»‘ lÆ°á»£ng products cáº§n insert (default: 1000)
     * @param batchSize Sá»‘ lÆ°á»£ng products má»—i batch (max 500 do giá»›i háº¡n Firestore)
     * @return Sá»‘ lÆ°á»£ng products Ä‘Ã£ insert thÃ nh cÃ´ng
     */
    suspend fun insertFakeProducts(
        firestore: FirebaseFirestore,
        count: Int = 1000,
        batchSize: Int = 100
    ): Result<Int> {
        return try {
            Log.d(TAG, "ğŸš€ Starting to insert $count fake products...")

            var totalInserted = 0
            val batches = (count + batchSize - 1) / batchSize  // Ceiling division

            for (batchIndex in 0 until batches) {
                val startIndex = batchIndex * batchSize
                val endIndex = minOf((batchIndex + 1) * batchSize, count)
                val currentBatchSize = endIndex - startIndex

                Log.d(TAG, "ğŸ“¦ Batch ${batchIndex + 1}/$batches: Inserting $currentBatchSize products...")

                // Táº¡o batch write
                val batch = firestore.batch()

                for (i in startIndex until endIndex) {
                    val fakeProduct = generateFakeProduct(i)

                    // Táº¡o document vá»›i auto-generated ID
                    val docRef = firestore.collection(COLLECTION_PRODUCTS).document()

                    // Convert Product to Map vÃ  thÃªm field isFakeData
                    val productMap = productToMap(fakeProduct).toMutableMap()
                    productMap["isFakeData"] = true  // âš ï¸ QUAN TRá»ŒNG: ÄÃ¡nh dáº¥u fake data

                    batch.set(docRef, productMap)
                }

                // Commit batch
                batch.commit().await()
                totalInserted += currentBatchSize

                Log.d(TAG, "âœ… Batch ${batchIndex + 1} completed. Total: $totalInserted/$count")
            }

            Log.d(TAG, "ğŸ‰ Successfully inserted $totalInserted fake products!")
            Result.success(totalInserted)

        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error inserting fake products", e)
            Result.failure(e)
        }
    }

    /**
     * Generate 1 fake product
     */
    private fun generateFakeProduct(index: Int): Product {
        val category = categories[index % categories.size]
        val adjective = adjectives[Random.nextInt(adjectives.size)]
        val material = materials[Random.nextInt(materials.size)]

        return Product(
            id = "",  // Auto-generated by Firestore
            name = "$adjective $material $category",
            price = (50 + Random.nextInt(450)).toFloat(),  // $50 - $500
            category = category,
            stock = Random.nextInt(100),  // 0-99
            averageRating = 3.0f + Random.nextInt(20) / 10f,  // 3.0-5.0
            offerPercentage = if (Random.nextInt(3) == 0) {
                0.05f + Random.nextInt(30) / 100f  // 5%-35% off
            } else {
                null
            },
            images = listOf(
                "https://picsum.photos/seed/${index}/400/400",
                "https://picsum.photos/seed/${index + 10000}/400/400"
            )
        )
    }

    /**
     * Convert Product to Map for Firestore
     */
    private fun productToMap(product: Product): Map<String, Any?> {
        return mapOf(
            "name" to product.name,
            "price" to product.price,
            "category" to product.category,
            "stock" to product.stock,
            "averageRating" to product.averageRating,
            "offerPercentage" to product.offerPercentage,
            "images" to product.images
        )
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // DELETE FAKE DATA
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

    /**
     * XÃ³a Táº¤T Cáº¢ fake products tá»« Firebase
     *
     * âš ï¸ CHÃš Ã: CHá»ˆ xÃ³a products cÃ³ isFakeData = true
     *
     * @return Sá»‘ lÆ°á»£ng products Ä‘Ã£ xÃ³a
     */
    suspend fun deleteAllFakeProducts(firestore: FirebaseFirestore): Result<Int> {
        return try {
            Log.d(TAG, "ğŸ—‘ï¸ Starting to delete fake products...")

            // Query táº¥t cáº£ fake products
            val snapshot = firestore.collection(COLLECTION_PRODUCTS)
                .whereEqualTo("isFakeData", true)
                .get()
                .await()

            if (snapshot.isEmpty) {
                Log.d(TAG, "â„¹ï¸ No fake products found")
                return Result.success(0)
            }

            val totalCount = snapshot.size()
            Log.d(TAG, "ğŸ“‹ Found $totalCount fake products. Deleting...")

            var deletedCount = 0
            val batchSize = 500  // Firestore batch limit

            // Delete theo batch
            val batches = (totalCount + batchSize - 1) / batchSize
            val documents = snapshot.documents

            for (batchIndex in 0 until batches) {
                val startIndex = batchIndex * batchSize
                val endIndex = minOf((batchIndex + 1) * batchSize, totalCount)

                val batch = firestore.batch()

                for (i in startIndex until endIndex) {
                    batch.delete(documents[i].reference)
                }

                batch.commit().await()
                deletedCount += (endIndex - startIndex)

                Log.d(TAG, "âœ… Batch ${batchIndex + 1}/$batches deleted. Total: $deletedCount/$totalCount")
            }

            Log.d(TAG, "ğŸ‰ Successfully deleted $deletedCount fake products!")
            Result.success(deletedCount)

        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error deleting fake products", e)
            Result.failure(e)
        }
    }

    /**
     * Count sá»‘ lÆ°á»£ng fake products hiá»‡n táº¡i
     */
    suspend fun countFakeProducts(firestore: FirebaseFirestore): Result<Int> {
        return try {
            val snapshot = firestore.collection(COLLECTION_PRODUCTS)
                .whereEqualTo("isFakeData", true)
                .get()
                .await()

            Result.success(snapshot.size())
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error counting fake products", e)
            Result.failure(e)
        }
    }

    /**
     * Count tá»•ng sá»‘ products (bao gá»“m cáº£ real vÃ  fake)
     */
    suspend fun countAllProducts(firestore: FirebaseFirestore): Result<Int> {
        return try {
            val snapshot = firestore.collection(COLLECTION_PRODUCTS)
                .get()
                .await()

            Result.success(snapshot.size())
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error counting all products", e)
            Result.failure(e)
        }
    }
}